TestNG: Test Next Generation is a testing framework inspired by JUnit and NUnit only in Java
-> Powerful features such as parallel execution, grouping, data-driven testing and better reporting
-> Unit test, functional test, integration test
------------------------------------------------------------------------------------------------------------------
Basic Structure:

<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE suite SYSTEM "https://testng.org/testng-1.0.dtd">
<suite name="TestNG">
    <test name="Practice">
        <classes>
            <class name="TestNG.TestNG_Practice"> <!-- Syntax: <class name="package.className"> -->
                <methods>
                    <include name="run" /> <!-- Syntax: <include name="MethodName inside defined class" /> -->
                </methods>
            </class>
        </classes>
    </test>
</suite>
-----------------------------------------------------------------------------------------------------------------
Assertions: Comparison between Actual and Expected

assertEquals - Positive scenarios
assertNotEquals - Negative scenarios
assertTrue
assertFalse
assertNull
assertNotNull

//Instead of writing below line everytime calling method with Assert class name
Assert.assertEquals(driver.findElement(By.id("output")).getText(),"You selected alert popup");

//can write as below by importing static import class statement
assertEquals(driver.findElement(By.id("output")).getText(),"You selected alert popup");

//By using this static import statement
import static org.testng.Assert.*; //use this line to reduce

HardAssertion: Throws exception immediately upon failure and won't execute rest - Assert class all methods comes under Hart Assertions
SoftAssertion: Throws exception at end of test or at specified location - methods from SoftAssert

As Assert is static class no need of object creation, but for soft assert
SoftAssert softassert = new SoftAssert(); //object creation
softassert.assertEquals(actual,expected,"message"); //assertion
softassert.assertAll();//throws error at specified location
------------------------------------------------------------------------------------------------------------------

Annotation: TestNG just used annotations from Java not created newly (Ex: @Override, @FunctionalInterface)
-> it is a form of metadatathat can be added to the java source code.

Hierarchy of TestNG Annotations
The sequence in which TestNG annotations are executed is as follows:

@BeforeSuite: This method runs before the execution of all the test methods in the suite.
@BeforeTest: This method runs before the execution of all the test methods in the test.
@BeforeClass: This method runs before the first method of the current class is invoked.
@BeforeMethod: This method runs before each test method.
@Test: This is the actual test method where the main business logic resides.
@AfterMethod: This method runs after each test method.
@AfterClass: This method runs after all the test methods of the current class have been executed.
@AfterTest: This method runs after the execution of all the test methods in the test.
@AfterSuite: This method runs after the execution of all the test methods in the suite.

@Parameters: To pass any info to testNG methods need to use Parameters
-> should declare below suite tag in testng.xml along with method where need to use parameters
-> <parameter name="browserName" value="Chrome"></parameter> //in testNG.xml
-> @Parameters({"browsername","url"}) //above method if multiple variables use array
-> @Parameters("url") //pass single string if single variable

@OptionalParameter: if user forgot to mention value to parameter then default value will be considered
-> Syntax:
    public void method_Name(@Optional("chrome") String browsername){ }

    If user forgot to pass browser name in testng.xml then it consider chrome
    If user provide edge in testng.xml then priority will comes to edge

@BeforeGroup:
@AfterGroup:
@DataProvider:

@Factory:
@Listeners:
@Ignore:

-----------------------------------------------------------------------------------------------------------------
Enable or Disable Tests:

In testng.xml:
<test name="Basic Controls" enabled="true"> <!-- By default it will be true-->
<test name="Basic Controls" enabled="false"> <!-- to Disable -->

In Classes or methods:
@Test(enabled=False)
------------------------------------------------------------------------------------------------------------------
Prioritize Tests:

@Test(priority=1)
-> If we don't mention priority they will execute in ASCI order so, need to mention priority
-> Default value of priority is "0" that means priority with 0 will execute 1st, then after priority 1,2,3...
-> we can pass -ve values (-1 will execute 1st and 0 will execute after that)
-> If we provide same priority, then it follows ASCI among those same priority tests
-------------------------------------------------------------------------------------------------------------
Ignore Tests: Added at method level

@Ignore
@Test(enabled=True) //still Ignores bcoz of priority Ignore Vs Enabled
public method(){}..

-> To Ignore all tests in class level declare @Ignore at class level
-> To Ignore package level - create package-info.java in
In package-info.java

@Ignore
package package_Name
import org.testng.annotations.Ignore;
-----------------------------------------------------------------------------------------------------------------
Grouping Tests:

-> We can create diff .xml files for diff categories
Ex: Smoke.xml, Regression.xml...

Instead of creating multiple .xml files we can group them and run accordingly
-> Declaration at class level
@Test(group={"Smoke","sanity","regression"}) //groups expects string of array
-> Declaration at .xml level
-> If group not assigned to a method then it won't be considered bcoz not part of group
-> if we don't introduce groups concept in .xml then all tests will be considered for execution
> Group of Groups: Using define tags in .xml

<suite name="Selenium Practice">
    <groups> <!--groups at suite level applicable to all tests-->
        <run>
            <include name="smoke"/>
        </run>
    </groups>
    <parameter name="browsername" value="Edge"/>
    <test name="Basic Controls">
        <groups> <!-- Declaring groups at test level only applicable to respective tests-->
            <define name="Daily">
                <include name="smoke"/>
                <include name="functional"/>
            </define>
            <define name="Weekly">
                <include name="smoke"/>
                <include name="functional"/>
                <include name="regression"/>
            </define>
            <run>
                <include name="Daily"/>
            </run>
        </groups>
        <classes>
            <class name="TestNG.TestNG_Groups"/>
        </classes>
    </test>
</suite>

RegEx:
If groups named like windows.smoke, windows.functional....
then we can use windows.* to run all
----------------------------------------------------------------------------------------------------------------
Test Dependancy: Tests dependent on pre-tests

@Test(dependsOnMethods={"LaunchBrowser","Login"}) //will execute only after those methods get passed else skip the execution
-> Even though we declare priority it will consider dependancy 1st
@Test(dependsOnMethods={"LaunchBrowser","Login"},alwaysRun=true)
-> But if alwaysRun declares the it will consider over dependancy

Group Dependencies: Achieved via .xml file using dependencies tags

<suite name="Selenium Practice">
    <parameter name="browsername" value="Edge"/>
    <test name="Basic Controls">
        <groups>
            <dependencies>
                <group name="sanity" depends-on="smoke"></group>
                <group name="regression" depends-on="sanity"></group>
            </dependencies>
        </groups>
        <classes>
            <class name="TestNG.TestNG_GroupDependencies"/>
        </classes>
    </test>
</suite>

---------------------------------------------------------------------------------------------------------------
Data Provider: A container which passes data to our test methods, can execute with different sets of data

@DataProvider(name = "test") //name for data provider to access uniquely
@Test(dataProvider = "test") // use that unique name at where the data has to pass to test method

-> What happens if we don;t provide name to DataProvider
If we don't provide name to dataProvider, then it will throw runtime exception
If we are not passing any name to data provider then bu default respective method name will be assigned to it

-> Is it mandatory to provide Object[][] to DataProvider method?
    Object[]
    Object[][]
    Iterator<Object> - these are used when we store data in form of collections (like List, Set, Map)... then return data.iterator();
    Iterator<Object[]>
If we know specific data type of variables then can use String[] or Integer[]
But if we are using mixed types then use Object[] bcoz, its super class of all datatypes arrays

>>> Indices : Use DataProvider partially in TestNG - Nothing but indexes off data which only need to pass
It is a parameter in @dataProvider(indices = {0,2}) which accepts int[] nothing bus index of datas

>>> Create DataProviders in seperate class
Can we Seperate? - Yes
What is dataProviderClas? Why do we use? - It is an attribute which accept class as an argument to pass data from another class
How to use dataProviderClass? - @Test(dataProvider="data", dataProviderClass = Data.class) //Syntax
Can we store multiple DataProviders in dataPrivoderClass? - Yes, but executes only which one is specified
Can we Have multiple dataProvidersClasses in a package? - Yes, but executes only which one is specified

>>> Integration of Excel with DataProvider : To achieve dynamic data providing to test instead of statically updating in code level

Libraries available fro reading data from excel - Apache POI (which supports both older .xls version and newer .xlsx versions)
Excel->Workbook->Sheet->Rows->Cells
../SeleniumJava/src/test/java/TestNG/ExcelDataProvider.java  - Code Explanation

>>> Parallel Execution in Data Provider
@DataProvider(parallel=true) //for parallel execution
@DataProvider(parallel=false) //By default it will be false to execute in sequential

>>> ThreadCount for DataProvider level - Should declare in .xml file at suite level
<suite name="Suite" data-provider-thread-count="2"> //dataProvider ThreadCount allows those set of test data only & declare at suite level
  <test thread-count="5" name="Test"> //Test case thread count at Test Level
  
----------------------------------------------------------------------------------------------------------------------

>>> Timeout & Expected Expectations are 2 attributes in TestNG Test annotation

Timeout - if we are expecting specific TC to complete in specific time
@Test(timeOut=2000) //Syntax

Exceptions - Not mostly useful to Testers but for dev while Negative testing unit TestCases expeced to fail with known exceptions
 @Test(expectedExceptions= {NoSuchElementException.class, TimeoutException.class}) //Syntax
 
---------------------------------------------------------------------------------------------------------------------------

>>> Parallel Testing - achieved via only textNG.xml file

2 Attributes used at suite level or at test level based on convinience - Parallel & thread-count 

-> If we only mention parallel and don't mention thread count, then by default thread-count will be "5"

parallel="false" , parallel="none" - Sequential
thread-count="1" - Sequential
thread-count="-1" - IllegalArgumentException

<suite name="Suite" parallel="tests" data-provider-thread-count="2"> //will pick 2 tests and run them parallelly
<test name="Suite" parallel="classes" data-provider-thread-count="2"> //will pick tests in sequential but run classes parallely
<test name="Suite" parallel="methods" data-provider-thread-count="2"> //will pick tests in sequential but run classes parallely

-----------------------------------------------------------------------------------------------------------------------------

>>> Invocation Count: Execute same piece of code multiple times considering each iteration as individual test
-> If one iteration failed also it won't hault, will continue rest

@Test(invocationCount = 3) - Will run same method 3 times

>>> Invocation Timeout: All tests which are invocated through invocationCount should complete within specified timeout parameter

@Test(invocationCount=3, invocationTimeOut=10000) - All 3 Tests should complete in 10s

>>> Thread Pool Size - Declaring no.of threads needed at test method level

@Test(invocationCount=4, threadPoolSize=2) - Will run test 4 times using 2 threads

--------------------------------------------------------------------------------------------------------------------------------

>>> Listeners - Listener is an Interface in testNg 
-> Which listenes the events performed by testNG
-> To perform actions based on events, Listeners are used

>>> TestListenerAdapter class implements all these below interfaces which can use to workn on all these
Eg: 
IAnnotationTransformer
IAnnotationTransformer2
IHookable
IInvokedMethodListener
IMethodInterceptor
IReporter
ISuiteListener

>>> ITestListener : Should implement interface and override our required actions inside it

public class ITestListenerPractice implements ITestListener{
	@Override
	public void onTestStart(ITestResult result) {
		System.out.println("onTestStart");
	}
}

> Implementation at class level inside class files

@Listeners({ITestListenerPractice.class,...if any extra listeners.class})
public class Test{
}

> Implementation at suite level in .xml files	

<suite name="Suite" parallel="tests" data-provider-thread-count="2">
	<listeners>
		<listener class-name="TestNG.Listener.class"/>
	</listeners>

------------------------------------------------------------------------------------------------------------------------

Capturing screenshots using
> TestNGListeners - onTestFailure(ITestResult result) - result object holds some parameters like 
result.getTestName, result.getTestClass , getName() {we can use getName() instead of result.getMethod().getMethodName()} ... with these we can save screenshot name uniquely
In orderto save older screenshots.. implement date timestamp for sub folder to save in unique folders

> Dependency Injection  -We eill not be sending values, TestNG will inject values at runtime

We need to add one annotation called @AfterMethod
@AfterMethod
public void captureScreenshot(ITestResult result){ //getting status failed/ passed/ skipped from result obj after every method get executed
	if(result.getStatus()==ITestResult.FAILURE){
		captureSS(result.getName+".jpg");
	}
}

-----------------------------------------------------------------------------------------------------------------------

>>> Default Reports by TestNG - test-output/index.html in project which is generated by testNG by default

>>> Alternate Reports: Extent Reports/ Allure Reports
